package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/coze-dev/coze-sdk-gen/internal/config"
	"github.com/coze-dev/coze-sdk-gen/internal/openapi"
)

type goOperationBinding struct {
	MethodName string
	Path       string
	Method     string
	Summary    string
}

func GenerateGo(cfg *config.Config, doc *openapi.Document) (Result, error) {
	if cfg == nil {
		return Result{}, fmt.Errorf("config is required")
	}
	if doc == nil {
		return Result{}, fmt.Errorf("swagger document is required")
	}

	bindings := buildGoOperationBindings(cfg, doc)
	if len(bindings) == 0 {
		return Result{}, fmt.Errorf("no operations selected for generation")
	}

	if err := os.RemoveAll(cfg.OutputSDK); err != nil {
		return Result{}, fmt.Errorf("clean output directory %q: %w", cfg.OutputSDK, err)
	}
	if err := os.MkdirAll(cfg.OutputSDK, 0o755); err != nil {
		return Result{}, fmt.Errorf("create output directory %q: %w", cfg.OutputSDK, err)
	}

	writer := &fileWriter{
		written: map[string]struct{}{},
	}
	if err := writeGoRuntimeScaffolding(cfg.OutputSDK, writer); err != nil {
		return Result{}, err
	}

	moduleContent, err := renderGoOperationModule(bindings)
	if err != nil {
		return Result{}, err
	}
	if err := writer.write(filepath.Join(cfg.OutputSDK, "apps.go"), moduleContent); err != nil {
		return Result{}, err
	}

	return Result{
		GeneratedFiles: writer.count,
		GeneratedOps:   len(bindings),
	}, nil
}

func buildGoOperationBindings(cfg *config.Config, doc *openapi.Document) []goOperationBinding {
	allOps := doc.ListOperationDetails()
	bindings := make([]goOperationBinding, 0, len(allOps))
	seen := map[string]int{}

	for _, details := range allOps {
		if cfg.IsIgnored(details.Path, details.Method) {
			continue
		}
		base := strings.TrimSpace(details.OperationID)
		if base == "" {
			base = defaultMethodName(details.OperationID, details.Path, details.Method)
		}
		name := normalizeGoExportedIdentifier(base)
		if name == "" {
			name = "Operation"
		}

		count := seen[name]
		seen[name] = count + 1
		if count > 0 {
			name = fmt.Sprintf("%s%d", name, count+1)
		}

		bindings = append(bindings, goOperationBinding{
			MethodName: name,
			Path:       details.Path,
			Method:     strings.ToUpper(details.Method),
			Summary:    oneLineText(details.Summary),
		})
	}
	return bindings
}

func writeGoRuntimeScaffolding(outputDir string, writer *fileWriter) error {
	textAssets := map[string]string{
		".gitignore":      "gitignore.raw",
		"codecov.yml":     "codecov.yml.raw",
		"go.mod":          "go.mod.raw",
		"go.sum":          "go.sum.raw",
		"LICENSE":         "LICENSE.raw",
		"CONTRIBUTING.md": "CONTRIBUTING.md.raw",
	}
	for target, asset := range textAssets {
		content, err := renderGoRuntimeAsset(asset)
		if err != nil {
			return err
		}
		if target == ".gitignore" || target == "codecov.yml" || target == "LICENSE" {
			content = strings.TrimSuffix(content, "\n")
		}
		if err := writer.write(filepath.Join(outputDir, target), content); err != nil {
			return err
		}
	}

	goAssets := map[string]string{
		"audio.go":                         "audio.go.raw",
		"client.go":                        "client.go.raw",
		"const.go":                         "const.go.raw",
		"enterprises.go":                   "enterprises.go.raw",
		"stores.go":                        "stores.go.raw",
		"user_agent.go":                    "user_agent.go.raw",
		"websocket.go":                     "websocket.go.raw",
		"websocket_audio.go":               "websocket_audio.go.raw",
		"websocket_audio_speech.go":        "websocket_audio_speech.go.raw",
		"websocket_audio_transcription.go": "websocket_audio_transcription.go.raw",
		"websocket_chat.go":                "websocket_chat.go.raw",
	}
	for target, asset := range goAssets {
		content, err := renderGoRuntimeAsset(asset)
		if err != nil {
			return err
		}
		formatted, err := format.Source([]byte(content))
		if err != nil {
			return fmt.Errorf("format go runtime file %q: %w", target, err)
		}
		if err := writer.write(filepath.Join(outputDir, target), string(formatted)); err != nil {
			return err
		}
	}
	return nil
}

func renderGoOperationModule(bindings []goOperationBinding) (string, error) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by coze-sdk-gen. DO NOT EDIT.\n")
	buf.WriteString("package coze\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString(")\n\n")
	buf.WriteString("type apps struct {\n")
	buf.WriteString("\tcore *core\n")
	buf.WriteString("}\n\n")
	buf.WriteString("func newApps(core *core) *apps {\n")
	buf.WriteString("\treturn &apps{core: core}\n")
	buf.WriteString("}\n\n")

	for _, op := range bindings {
		if op.Summary != "" {
			buf.WriteString("// ")
			buf.WriteString(op.Summary)
			buf.WriteByte('\n')
		}
		buf.WriteString(fmt.Sprintf("// %s wraps %s %s.\n", op.MethodName, op.Method, op.Path))
		buf.WriteString(fmt.Sprintf("func (r *apps) %s(ctx context.Context, params map[string]any, body map[string]any) (any, error) {\n", op.MethodName))
		buf.WriteString("\trequest := &RawRequestReq{\n")
		buf.WriteString(fmt.Sprintf("\t\tMethod: %s,\n", goHTTPMethodConst(op.Method)))
		buf.WriteString(fmt.Sprintf("\t\tURL:    %q,\n", op.Path))
		buf.WriteString("\t\tQuery:  params,\n")
		buf.WriteString("\t\tBody:   body,\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\tresponse := new(map[string]any)\n")
		buf.WriteString("\terr := r.core.rawRequest(ctx, request, response)\n")
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString("\t\treturn nil, err\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn response, nil\n")
		buf.WriteString("}\n\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return "", fmt.Errorf("format generated go sdk: %w", err)
	}
	return string(formatted), nil
}

func goHTTPMethodConst(method string) string {
	switch strings.ToUpper(strings.TrimSpace(method)) {
	case "GET":
		return "http.MethodGet"
	case "POST":
		return "http.MethodPost"
	case "PUT":
		return "http.MethodPut"
	case "PATCH":
		return "http.MethodPatch"
	case "DELETE":
		return "http.MethodDelete"
	case "OPTIONS":
		return "http.MethodOptions"
	case "HEAD":
		return "http.MethodHead"
	case "TRACE":
		return "http.MethodTrace"
	default:
		return fmt.Sprintf("%q", strings.ToUpper(strings.TrimSpace(method)))
	}
}

func normalizeGoExportedIdentifier(value string) string {
	parts := splitIdentifierWords(value)
	if len(parts) == 0 {
		return ""
	}
	var buf strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		runes := []rune(part)
		first := unicode.ToUpper(runes[0])
		buf.WriteRune(first)
		if len(runes) > 1 {
			buf.WriteString(string(runes[1:]))
		}
	}
	result := buf.String()
	if result == "" {
		return ""
	}
	firstRune := []rune(result)[0]
	if unicode.IsDigit(firstRune) {
		return "Op" + result
	}
	return result
}

func splitIdentifierWords(value string) []string {
	if value == "" {
		return nil
	}
	fields := strings.FieldsFunc(value, func(r rune) bool {
		return !(unicode.IsLetter(r) || unicode.IsDigit(r))
	})
	words := make([]string, 0, len(fields))
	for _, field := range fields {
		if field == "" {
			continue
		}
		words = append(words, field)
	}
	return words
}

func oneLineText(value string) string {
	value = strings.TrimSpace(value)
	if value == "" {
		return ""
	}
	return strings.Join(strings.Fields(value), " ")
}
